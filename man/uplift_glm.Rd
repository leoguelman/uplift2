% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/uplift_glm.R
\name{uplift_glm}
\alias{uplift_glm}
\alias{uplift_glm.formula}
\alias{print.uplift_glm}
\title{Fitting Uplift Generalized Linear Models.}
\usage{
\method{uplift_glm}{formula}(formula, data, subset, na.action,
  family = "gaussian", method = "glm", sampling = "weights",
  treatLevel = NULL, Anova = FALSE, ...)

\method{print}{uplift_glm}(x, ...)
}
\arguments{
\item{formula}{A model formula of the form y ~ x1 + ....+ xn + trt(), where
the left-hand side corresponds to the observed response, the right-hand side
corresponds to the predictors, and 'trt' is the special expression to mark
the treatment term. If the treatment term is not a factor, it is converted
to one.}

\item{data}{A data frame in which to interpret the variables named in the
formula.}

\item{subset}{Expression indicating which subset of the rows of data should be
included. All observations are included by default.}

\item{na.action}{A missing-data filter function.}

\item{family}{Response type. For \code{family = "gaussian"} (default), the
response must be presented as numeric. For \code{family = "binomial"}, the
response must be a factor with two levels. If the response is numeric,  it
will be coerced into a factor. For \code{family = "cox"}, the response must
be a survival object, as returned by \code{survival::Surv}.}

\item{method}{The method used for model fitting. If \code{method = "glm"}
(default), the model is fitted on the modified covariates (see details)
using \code{stats::glm}. If \code{method = "glmStepAIC"}, the model is first
fitted using \code{stats::glm} and then this is passed to
\code{MASS::stepAIC} for AIC stepwise selection. Alternatively, for
\code{method = "glmnet"} and \code{method = "cv.glmnet"}, models are fitted
using \code{glmnet::glmnet} and \code{glmnet::cv.glmnet}, respectively.}

\item{sampling}{The sampling method used to balance the treatment variable.
See details.}

\item{treatLevel}{A character string for the treatment level of interest.
Defaults to the last level of the treatment factor.}

\item{Anova}{If \code{TRUE}, the analysis-of-variance table is returned using
the function \code{car::Anova}. It does not apply to \code{method =
"cv.glmnet"} or \code{method = "glmnet"}.}

\item{\dots}{Additional arguments passed to the regression method selected in
\code{method}.}

\item{x}{A \code{uplift_glm} object.}
}
\value{
An object of class \code{"uplift_glm"}, which is a list with the
 following components, in addition to the ones returned by the specific
 fitting method:

 \itemize{ \item \code{call} The calling expression \item \code{na.action}
 Information returned by \code{model.frame} on the special handling of NAs.
 \item \code{xlevels} The levels of predictors of class factor. \item
 \code{Family} The \code{family} used. \item \code{method} The \code{method}
 used. \item \code{sampling} The \code{sampling} method used. \item
 \code{dataClasses} The data classes of predictors. \item \code{treatLevel}
 The reference treatment level. \item \code{ttReLabel} The label of the
 transformed treatment indicator. \item \code{modForm} The model formula.
 \item \code{modData} The data frame used in model fitting. \item
 \code{inbag} The index of of which observations were used for fitting. \item
 \code{weightVector} The vector of weights used for fitting.}
}
\description{
\code{uplift_glm} fits Uplift Generalized Linear Models, optionally with lasso
or elasticnet regularization.
}
\details{
The function follows the method for uplift modeling proposed by Tian et al.
(2014). This method consists in modifying the covariates in a simple way, and
then fitting an appropriate regression model using the modified covariates and
no main effects. See Tian et al. (2014) for details.

The argument \code{sampling} can be used to obtain a balanced treatment
distribution. Specifically, if \code{sampling = "oversample"}, observations
from the treatment minority class are duplicated (by sampling with
replacement), so that the data frame used in model fitting has exactly the
same number of observations under each treatment level. Alternatively, if
\code{sampling = "undersample"}, observations from the treatment majority
class are dropped (by sampling without replacement), so that the data frame
used in model fitting has exactly the same number of observations under each
treatment level. If \code{sampling = "none"}, no sampling is done. Lastly, if
\code{sampling = "weights"}, the returned data frame includes a weight
variable that equals (1 - \eqn{\pi}) for T = \code{treatLevel}  and \eqn{\pi}
otherwise, where \eqn{\pi = Prob(T = treatLevel)}. These weights are
subsequently used as case weights in the fitting process.
}
\examples{

set.seed(1)
df_train <- sim_uplift(p = 50, response = "binary")
df_test<- sim_uplift(p = 50, n = 10000, response = "binary")
form <- as.formula(paste('y ~', 'trt(T) +',
       paste('X', 1:(ncol(df_train)-3), sep = '', collapse = "+")))
fit1 <- uplift_glm(form,
                  family = "binomial",
                  method = "glm",
                  data = df_train)
fit1
fit2 <- uplift_glm(form,
                  family = "binomial",
                  method = "glmStepAIC",
                  data = df_train)
fit2
fit3 <- uplift_glm(form,
                  family = "binomial",
                  method = "cv.glmnet",
                  data = df_train)
lambda.opt <- fit3$lambda.min
fit3 <- uplift_glm(form,
                  family = "binomial",
                  method = "glmnet",
                  data = df_train)
upliftPred1 <- predict(fit1, df_test)
upliftPred2 <- predict(fit2, df_test)
upliftPred3 <- predict(fit3, df_test, s=lambda.opt)
df_eval<- data.frame(upliftPred1 = upliftPred1,
                    upliftPred2 = upliftPred2,
                    upliftPred3 = upliftPred3,
                    y = df_test$y,
                    T = df_test$T)
res <- inspect_performance(y ~ upliftPred1 + upliftPred2 + upliftPred3 + trt(T),
                          data = df_eval, qini = TRUE)
res
summary(res)
ggplot(res)
res$qiniC
}
\references{
Tian, L., Alizadeh, A., Gentles, A. and Tibshirani, R. (2014). "A simple
method for detecting interactions between a treatment and a large number of
covariates." Journal of the American Statistical Association, 109:508, pp.
1517--1532.
}
\author{
Leo Guelman \email{leo.guelman@gmail.com}
}
